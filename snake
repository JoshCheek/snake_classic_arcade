#!/usr/bin/env ruby

# ANSI stuffs!
BLACK   = "\e[40m"
RED     = "\e[41m"
GREEN   = "\e[42m"
YELLOW  = "\e[43m"
BLUE    = "\e[44m"
MAGENTA = "\e[45m"
TEAL    = "\e[46m"
WHITE   = "\e[47m"

HIDE_CURSOR = "\e[?25l"
SHOW_CURSOR = "\e[?25h"

def to(y, x)
  "\e[#{y};#{x*2-1}H"
end

# best practices :P
class Complex
  alias y imaginary
  alias x real
  def to_a() [y, x] end
end

# some fkn classes, yo
Item = Struct.new :duration, :obstructs, :to_s do
  alias obstructs? obstructs

  def expired?
    duration <= 0
  end

  def tick_tock
    Item.new duration-1, obstructs, to_s
  end

  def food?
    false
  end
end

WALL  = Item.new Float::INFINITY, true,  BLUE
FLOOR = Item.new Float::INFINITY, false, BLACK


class Snake < Item
  attr_reader :position, :direction

  alias length duration

  def initialize(position, direction, length, to_s)
    @position  = position
    @direction = direction
    @expired   = false
    super length, true, to_s
  end

  def slither
    next_direction = @next_direction || direction
    next_direction = direction if next_direction == -direction
    self.class.new position+next_direction, next_direction, length, to_s
  end

  def face(direction)
    @next_direction = direction
    self
  end

  def grow(n)
    self.class.new position, direction, length+n, to_s
  end

  def to_a
    position.to_a
  end

  def die!
    @expired = true
  end

  def expired?
    @expired
  end
end


class Food < Item
  # FIXME: do I need a position?
  attr_reader :position

  def initialize(position, to_s)
    @position = position
    super Float::INFINITY, false, to_s
  end

  def food?
    true
  end
  def tick_tock
    Food.new duration-1, to_s
  end
end


# ANSI terminal setup
require 'io/console'
rows, cols = $stdin.winsize
cols /= 2 # each location will take 2 cols
$stdin.raw!
print HIDE_CURSOR
at_exit do
  $stdin.cooked!
  print SHOW_CURSOR
end



# mah snake!
snake = Snake.new cols.succ/2 + rows.succ/2*1i, -1+0i, 4, WHITE

# mah board!
board = Hash.new FLOOR
board[snake.position] = snake
rows.times { |y| board[1 + (y+1)*1i] = board[cols + (y+1)*1i] = WALL }
cols.times { |x| board[x+1 + 1i] = board[x+1 + rows*1i] = WALL }

# gotsta get fed
define_method :mas_comida_por_favor! do
  position = loop do
    y = rand(rows).succ
    x = rand(cols).succ
    p = x + y*1i
    i = board[p]
    break p if FLOOR == i
  end
  food = Food.new position, MAGENTA
  board[position] = food
  position
end
mas_comida_por_favor!

# print the initial board
print "\e[H"
1.upto rows do |y|
  1.upto cols do |x|
    print "#{to y, x}#{board[x + y*1i]}  "
  end
end

# game can end without the snake dying
quit = false

# read them inputs
input_handler = Thread.new do
  Thread.abort_on_exception = true
  until snake.expired? || quit
    begin
      input = $stdin.read_nonblock(1)
      case input
      when ?\C-c, ?\C-d, ?q then quit  = true
      when ?h               then snake = snake.face -1 + 0i
      when ?l               then snake = snake.face  1 + 0i
      when ?j               then snake = snake.face  0 + 1i # backwards b/c origin is top-right
      when ?k               then snake = snake.face  0 - 1i
      else                       # noop
      end
    rescue IO::WaitReadable
      # no input available
    end
  end
end


updater = Thread.new do
  Thread.abort_on_exception = true
  until snake.expired? || quit
    sleep 0.08

    items                 = board.map { |pos, item| [pos, item.tick_tock] }
    to_delete, next_board = items.partition { |_, item| item.expired? }
    board                 = next_board.to_h.tap { |h| h.default = board.default }

    to_delete.each { |position, item| print "#{to *position}#{FLOOR}  " }

    snake   = snake.slither
    current = board[snake.position]
    if current.obstructs?
      snake.die!
    elsif current.food?
      snake = snake.grow 3
      pos   = mas_comida_por_favor!
      print "#{to *pos}#{board[pos]}  "
    end
    board[snake.position] = snake
    print "#{to *snake}#{snake}  "
  end
end

input_handler.join
updater.kill if quit # don't wait for it to finish sleeping
updater.join

puts to(rows, 1)
