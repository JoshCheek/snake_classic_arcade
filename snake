#!/usr/bin/env ruby

# ANSI stuffs!
BLACK   = "\e[40m"
RED     = "\e[41m"
GREEN   = "\e[42m"
YELLOW  = "\e[43m"
BLUE    = "\e[44m"
MAGENTA = "\e[45m"
TEAL    = "\e[46m"
WHITE   = "\e[47m"

HIDE_CURSOR = "\e[?25l"
SHOW_CURSOR = "\e[?25h"

def to(y, x)
  "\e[#{y};#{x*2-1}H"
end

# best practices :P
class Complex
  alias y imaginary
  alias x real
  def to_a() [y, x] end
end

# some fkn classes, yo
Item = Struct.new :type, :duration, :obstructs, :str do
  alias obstructs? obstructs
  alias to_s       str

  def initialize(type:, duration: Float::INFINITY, obstructs: false, str:)
    super type, duration, obstructs, str
  end

  def expired?
    duration <= 0
  end

  def tick_tock
    new duration: duration-1
  end

  def food?()  type == :food  end
  def wall?()  type == :wall  end
  def floor?() type == :floor end
  def snake?() type == :snake end

  private

  def new(**overrides)
    self.class.new(to_h.merge overrides)
  end
end

class Food < Item
  def initialize(**rest)
    super type: :food, **rest
  end

  def food?
    true
  end

  def tick_tock
    self
  end
end


class Snake < Item
  attr_reader :position, :direction, :next_direction, :expired
  alias length   duration

  def initialize(position:, direction:, next_direction:nil, expired:false, length:nil, **rest)
    @position, @direction, @next_direction, @expired =
     position,  direction,  next_direction,  expired
    rest[:duration] = length || rest[:duration]
    super type: :snake, obstructs: true, **rest
  end

  def to_h
    super.merge position:       position,
                direction:      direction,
                next_direction: next_direction,
                expired:        expired
  end

  def slither
    dir = next_direction || direction
    dir = direction if dir == -direction
    new position: position+dir, direction: dir
  end

  def face(direction)
    new next_direction: direction
  end

  def grow(n)
    new length: length+n
  end

  def to_a
    position.to_a
  end

  def die
    new expired: true
  end

  def expired?
    expired || super
  end
end


# ANSI terminal setup
require 'io/console'
rows, cols = $stdin.winsize
cols /= 2 # each location will take 2 cols
$stdin.raw!;       at_exit { $stdin.cooked! }
print HIDE_CURSOR; at_exit { print SHOW_CURSOR }


# mah board items
WALL  = Item.new type: :wall,  obstructs: true,  str: "#{BLUE}  "
FLOOR = Item.new type: :floor, obstructs: false, str: "#{BLACK}  "
FOOD  = Food.new str: "#{MAGENTA}  "
snake = Snake.new position:  cols.succ/2 + rows.succ/2*1i,
                  direction: -1+0i,
                  length:    4,
                  str:       "#{WHITE}  "
# mah board!
board = Hash.new FLOOR
board[snake.position] = snake
rows.times { |y| board[1 + (y+1)*1i] = board[cols + (y+1)*1i] = WALL }
cols.times { |x| board[x+1 + 1i] = board[x+1 + rows*1i] = WALL }

# gotsta get fed
define_method :find_a_place_to_stash_some_food! do
  loop do
    p = rand(cols).succ + rand(rows).succ*1i
    break p if FLOOR == board[p]
  end
end
board[find_a_place_to_stash_some_food!] = FOOD

# print the initial board
1.upto rows do |y|
  1.upto cols do |x|
    print "#{to y, x}#{board[x + y*1i]}"
  end
end

# game can end without the snake dying
quit = false

# read them inputs
input_handler = Thread.new do
  Thread.abort_on_exception = true
  until snake.expired? || quit
    begin
      case $stdin.read_nonblock(1)
      when ?\C-c, ?\C-d, ?q then quit  = true
      when ?h               then snake = snake.face -1 + 0i
      when ?l               then snake = snake.face  1 + 0i
      when ?j               then snake = snake.face  0 + 1i # backwards b/c origin is top-right
      when ?k               then snake = snake.face  0 - 1i
      else                       # noop
      end
    rescue IO::WaitReadable
      # no input available
    end
  end
end


updater = Thread.new do
  Thread.abort_on_exception = true
  until snake.expired? || quit
    sleep 0.08

    items                 = board.map { |pos, item| [pos, item.tick_tock] }
    to_delete, next_items = items.partition { |_, item| item.expired? }
    board                 = next_items.to_h.tap { |h| h.default = board.default }

    to_delete.each { |position, item| print "#{to *position}#{FLOOR}" }

    snake   = snake.slither
    current = board[snake.position]
    if current.obstructs?
      snake = snake.die
    elsif current.food?
      snake      = snake.grow 3
      pos        = find_a_place_to_stash_some_food!
      board[pos] = FOOD
      print "#{to *pos}#{board[pos]}"
    end
    board[snake.position] = snake
    print "#{to *snake}#{snake}" unless snake.expired?
  end
end

input_handler.join
updater.kill if quit # don't wait for it to finish sleeping
updater.join

puts to(rows, 1)
